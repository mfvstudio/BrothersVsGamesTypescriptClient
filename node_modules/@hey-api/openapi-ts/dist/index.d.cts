import { C as Comments, I as ImportExportItemObject, t as tsNodeToString, s as stringToTsNodes, P as PluginHandler, a as Plugin, S as StringCase, U as UserConfig, b as Client, c as IR } from './types.d-CaH9PF-K.cjs';
export { j as Client, D as DefinePlugin, E as ExpressionTransformer, L as LegacyIR, O as OpenApi, d as OpenApiMetaObject, e as OpenApiOperationObject, f as OpenApiParameterObject, g as OpenApiRequestBodyObject, h as OpenApiResponseObject, i as OpenApiSchemaObject } from './types.d-CaH9PF-K.cjs';
import * as ts from 'typescript';
import ts__default from 'typescript';
import 'node:fs';

type AccessLevel = 'private' | 'protected' | 'public';
type FunctionParameter = {
    accessLevel?: AccessLevel;
    default?: any;
    isReadOnly?: boolean;
    isRequired?: boolean;
    name: string;
    type?: any | ts__default.TypeNode;
} | {
    destructure: ReadonlyArray<FunctionParameter>;
    type?: any | ts__default.TypeNode;
};
interface FunctionTypeParameter {
    default?: any;
    extends?: string | ts__default.TypeNode;
    name: string | ts__default.Identifier;
}
type SyntaxKindKeyword = 'any' | 'async' | 'boolean' | 'export' | 'never' | 'number' | 'private' | 'protected' | 'public' | 'readonly' | 'static' | 'string' | 'undefined' | 'unknown' | 'void';
type ObjectValue = {
    assertion?: 'any' | ts__default.TypeNode;
    comments?: Comments;
    spread: string;
} | {
    comments?: Comments;
    isValueAccess?: boolean;
    key: string;
    shorthand?: boolean;
    value: any;
};

type ImportExportItem = ImportExportItemObject | string;

type Property = {
    comment?: Comments;
    isReadOnly?: boolean;
    isRequired?: boolean;
    name: string | ts__default.PropertyName;
    type: any | ts__default.TypeNode;
};

declare const compiler: {
    anonymousFunction: ({ async, comment, multiLine, parameters, returnType, statements, types, }: {
        async?: boolean;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: FunctionParameter[];
        returnType?: string | ts.TypeNode;
        statements?: ts.Statement[];
        types?: FunctionTypeParameter[];
    }) => ts.FunctionExpression;
    arrayLiteralExpression: <T>({ elements, multiLine, }: {
        elements: T[];
        multiLine?: boolean;
    }) => ts.ArrayLiteralExpression;
    arrowFunction: ({ async, comment, multiLine, parameters, returnType, statements, types, }: {
        async?: boolean;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: ReadonlyArray<FunctionParameter>;
        returnType?: string | ts.TypeNode;
        statements?: ts.Statement[] | ts.Expression;
        types?: FunctionTypeParameter[];
    }) => ts.ArrowFunction;
    asExpression: ({ expression, type, }: {
        expression: ts.Expression;
        type: ts.TypeNode;
    }) => ts.AsExpression;
    assignment: ({ left, right, }: {
        left: ts.Expression;
        right: ts.Expression;
    }) => ts.AssignmentExpression<ts.EqualsToken>;
    awaitExpression: ({ expression, }: {
        expression: ts.Expression;
    }) => ts.AwaitExpression;
    binaryExpression: ({ left, operator, right, }: {
        left: ts.Expression;
        operator?: "=" | "===" | "in" | "??";
        right: ts.Expression | string;
    }) => ts.BinaryExpression;
    block: ({ multiLine, statements, }: {
        multiLine?: boolean;
        statements: Array<ts.Statement>;
    }) => ts.Block;
    callExpression: ({ functionName, parameters, types, }: {
        functionName: string | ts.PropertyAccessExpression | ts.PropertyAccessChain | ts.ElementAccessExpression | ts.Expression;
        parameters?: Array<string | ts.Expression | undefined>;
        types?: ReadonlyArray<ts.TypeNode>;
    }) => ts.CallExpression;
    classDeclaration: ({ decorator, exportClass, extendedClasses, name, nodes, }: {
        decorator?: {
            args: any[];
            name: string;
        };
        exportClass?: boolean;
        extendedClasses?: ReadonlyArray<string>;
        name: string;
        nodes: ReadonlyArray<ts.ClassElement>;
    }) => ts.ClassDeclaration;
    conditionalExpression: ({ condition, whenFalse, whenTrue, }: {
        condition: ts.Expression;
        whenFalse: ts.Expression;
        whenTrue: ts.Expression;
    }) => ts.ConditionalExpression;
    constVariable: ({ assertion, comment, destructure, exportConst, expression, name, typeName, }: {
        assertion?: "const" | ts.TypeNode;
        comment?: Comments;
        destructure?: boolean;
        exportConst?: boolean;
        expression: ts.Expression;
        name: string;
        typeName?: string | ts.IndexedAccessTypeNode | ts.TypeNode;
    }) => ts.VariableStatement;
    constructorDeclaration: ({ accessLevel, comment, multiLine, parameters, statements, }: {
        accessLevel?: AccessLevel;
        comment?: Comments;
        multiLine?: boolean;
        parameters?: FunctionParameter[];
        statements?: ts.Statement[];
    }) => ts.ConstructorDeclaration;
    enumDeclaration: <T extends Record<string, any> | Array<ObjectValue>>({ comments: enumMemberComments, leadingComment: comments, name, obj, }: {
        comments?: Record<string | number, Comments>;
        leadingComment?: Comments;
        name: string;
        obj: T;
    }) => ts.EnumDeclaration;
    exportAllDeclaration: ({ module, }: {
        module: string;
    }) => ts.ExportDeclaration;
    exportNamedDeclaration: ({ exports, module, }: {
        exports: Array<ImportExportItem> | ImportExportItem;
        module: string;
    }) => ts.ExportDeclaration;
    expressionToStatement: ({ expression, }: {
        expression: ts.Expression;
    }) => ts.ExpressionStatement;
    forOfStatement: ({ awaitModifier, expression, initializer, statement, }: {
        awaitModifier?: ts.AwaitKeyword;
        expression: ts.Expression;
        initializer: ts.ForInitializer;
        statement: ts.Statement;
    }) => ts.ForOfStatement;
    functionTypeNode: ({ parameters, returnType, typeParameters, }: {
        parameters?: ts.ParameterDeclaration[];
        returnType: ts.TypeNode;
        typeParameters?: ts.TypeParameterDeclaration[];
    }) => ts.FunctionTypeNode;
    identifier: ({ text }: {
        text: string;
    }) => ts.Identifier;
    ifStatement: ({ elseStatement, expression, thenStatement, }: {
        elseStatement?: ts.Statement;
        expression: ts.Expression;
        thenStatement: ts.Statement;
    }) => ts.IfStatement;
    indexedAccessTypeNode: ({ indexType, objectType, }: {
        indexType: ts.TypeNode;
        objectType: ts.TypeNode;
    }) => ts.IndexedAccessTypeNode;
    isTsNode: (node: any) => node is ts.Expression;
    keywordTypeNode: ({ keyword, }: {
        keyword: Extract<SyntaxKindKeyword, "any" | "boolean" | "never" | "number" | "string" | "undefined" | "unknown" | "void">;
    }) => ts.KeywordTypeNode<ts.SyntaxKind.VoidKeyword | ts.SyntaxKind.AnyKeyword | ts.SyntaxKind.BooleanKeyword | ts.SyntaxKind.NeverKeyword | ts.SyntaxKind.NumberKeyword | ts.SyntaxKind.StringKeyword | ts.SyntaxKind.UndefinedKeyword | ts.SyntaxKind.UnknownKeyword>;
    literalTypeNode: ({ literal, }: {
        literal: ts.LiteralTypeNode["literal"];
    }) => ts.LiteralTypeNode;
    mappedTypeNode: ({ members, nameType, questionToken, readonlyToken, type, typeParameter, }: {
        members?: ts.NodeArray<ts.TypeElement>;
        nameType?: ts.TypeNode;
        questionToken?: ts.QuestionToken | ts.PlusToken | ts.MinusToken;
        readonlyToken?: ts.ReadonlyKeyword | ts.PlusToken | ts.MinusToken;
        type?: ts.TypeNode;
        typeParameter: ts.TypeParameterDeclaration;
    }) => ts.MappedTypeNode;
    methodDeclaration: ({ accessLevel, comment, isStatic, multiLine, name, parameters, returnType, statements, types, }: {
        accessLevel?: AccessLevel;
        comment?: Comments;
        isStatic?: boolean;
        multiLine?: boolean;
        name: string;
        parameters?: ReadonlyArray<FunctionParameter>;
        returnType?: string | ts.TypeNode;
        statements?: ts.Statement[];
        types?: FunctionTypeParameter[];
    }) => ts.MethodDeclaration;
    namedImportDeclarations: ({ imports, module, }: {
        imports: Array<ImportExportItem> | ImportExportItem;
        module: string;
    }) => ts.ImportDeclaration;
    namespaceDeclaration: ({ name, statements, }: {
        name: string;
        statements: Array<ts.Statement>;
    }) => ts.ModuleDeclaration;
    newExpression: ({ argumentsArray, expression, typeArguments, }: {
        argumentsArray?: Array<ts.Expression>;
        expression: ts.Expression;
        typeArguments?: Array<ts.TypeNode>;
    }) => ts.NewExpression;
    nodeToString: typeof tsNodeToString;
    null: () => ts.NullLiteral;
    objectExpression: <T extends Record<string, any> | Array<ObjectValue>>({ comments, identifiers, multiLine, obj, shorthand, unescape, }: {
        comments?: Comments;
        identifiers?: string[];
        multiLine?: boolean;
        obj: T;
        shorthand?: boolean;
        unescape?: boolean;
    }) => ts.ObjectLiteralExpression;
    ots: {
        boolean: (value: boolean) => ts.TrueLiteral | ts.FalseLiteral;
        export: ({ alias, asType, name }: ImportExportItemObject) => ts.ExportSpecifier;
        import: ({ alias, asType, name }: ImportExportItemObject) => ts.ImportSpecifier;
        number: (value: number) => ts.NumericLiteral | ts.PrefixUnaryExpression;
        string: (value: string, unescape?: boolean) => ts.Identifier | ts.StringLiteral;
    };
    parameterDeclaration: ({ initializer, modifiers, name, required, type, }: {
        initializer?: ts.Expression;
        modifiers?: ReadonlyArray<ts.ModifierLike>;
        name: string | ts.BindingName;
        required?: boolean;
        type?: ts.TypeNode;
    }) => ts.ParameterDeclaration;
    propertyAccessExpression: ({ expression, isOptional, name, }: {
        expression: string | ts.Expression;
        isOptional?: boolean;
        name: string | number | ts.MemberName;
    }) => ts.PropertyAccessChain | ts.PropertyAccessExpression | ts.ElementAccessExpression;
    propertyAccessExpressions: ({ expressions, }: {
        expressions: Array<string | ts.Expression | ts.MemberName>;
    }) => ts.PropertyAccessExpression;
    propertyAssignment: ({ initializer, name, }: {
        initializer: ts.Expression;
        name: string | ts.PropertyName;
    }) => ts.PropertyAssignment;
    propertyDeclaration: ({ initializer, modifier, name, type, }: {
        initializer?: ts.Expression;
        modifier?: AccessLevel | "async" | "export" | "readonly" | "static";
        name: string | ts.PropertyName;
        type?: ts.TypeNode;
    }) => ts.PropertyDeclaration;
    regularExpressionLiteral: ({ flags, text, }: {
        flags?: ReadonlyArray<"g" | "i" | "m" | "s" | "u" | "y">;
        text: string;
    }) => ts.RegularExpressionLiteral;
    returnFunctionCall: ({ args, name, types, }: {
        args: any[];
        name: string | ts.Expression;
        types?: ReadonlyArray<string | ts.StringLiteral>;
    }) => ts.ReturnStatement;
    returnStatement: ({ expression, }: {
        expression?: ts.Expression;
    }) => ts.ReturnStatement;
    returnVariable: ({ expression, }: {
        expression: string | ts.Expression;
    }) => ts.ReturnStatement;
    safeAccessExpression: (path: string[]) => ts.Expression;
    stringLiteral: ({ isSingleQuote, text, }: {
        isSingleQuote?: boolean;
        text: string;
    }) => ts.StringLiteral;
    stringToTsNodes: typeof stringToTsNodes;
    templateLiteralType: ({ value, }: {
        value: ReadonlyArray<string | ts.TypeNode>;
    }) => ts.TemplateLiteralTypeNode;
    this: () => ts.ThisExpression;
    transformArrayMap: ({ path, transformExpression, }: {
        path: string[];
        transformExpression: ts.Expression;
    }) => ts.IfStatement;
    transformArrayMutation: ({ path, transformerName, }: {
        path: string[];
        transformerName: string;
    }) => ts.Statement;
    transformDateMutation: ({ path, }: {
        path: string[];
    }) => ts.Statement;
    transformFunctionMutation: ({ path, transformerName, }: {
        path: string[];
        transformerName: string;
    }) => ts.IfStatement[];
    transformNewDate: ({ parameterName, }: {
        parameterName: string;
    }) => ts.NewExpression;
    typeAliasDeclaration: ({ comment, exportType, name, type, typeParameters, }: {
        comment?: Comments;
        exportType?: boolean;
        name: string;
        type: string | ts.TypeNode;
        typeParameters?: FunctionTypeParameter[];
    }) => ts.TypeAliasDeclaration;
    typeArrayNode: (types: (any | ts.TypeNode)[] | ts.TypeNode | string, isNullable?: boolean) => ts.TypeNode;
    typeInterfaceNode: ({ indexKey, indexProperty, isNullable, properties, useLegacyResolution, }: {
        indexKey?: string;
        indexProperty?: Property;
        isNullable?: boolean;
        properties: Property[];
        useLegacyResolution: boolean;
    }) => ts.TypeNode;
    typeIntersectionNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: (any | ts.TypeNode)[];
    }) => ts.TypeNode;
    typeNode: (base: any | ts.TypeNode, args?: (any | ts.TypeNode)[]) => ts.TypeNode;
    typeOfExpression: ({ text }: {
        text: string;
    }) => ts.TypeOfExpression;
    typeOperatorNode: ({ operator, type, }: {
        operator: "keyof" | "readonly" | "unique";
        type: ts.TypeNode;
    }) => ts.TypeOperatorNode;
    typeParameterDeclaration: ({ constraint, defaultType, modifiers, name, }: {
        constraint?: ts.TypeNode;
        defaultType?: ts.TypeNode;
        modifiers?: Array<ts.Modifier>;
        name: string | ts.Identifier;
    }) => ts.TypeParameterDeclaration;
    typeParenthesizedNode: ({ type, }: {
        type: ts.TypeNode;
    }) => ts.ParenthesizedTypeNode;
    typeRecordNode: (keys: (any | ts.TypeNode)[], values: (any | ts.TypeNode)[], isNullable?: boolean, useLegacyResolution?: boolean) => ts.TypeNode;
    typeReferenceNode: ({ typeArguments, typeName, }: {
        typeArguments?: ts.TypeNode[];
        typeName: string | ts.EntityName;
    }) => ts.TypeReferenceNode;
    typeTupleNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: Array<any | ts.TypeNode>;
    }) => ts.TypeNode;
    typeUnionNode: ({ isNullable, types, }: {
        isNullable?: boolean;
        types: (any | ts.TypeNode)[];
    }) => ts.TypeNode;
    valueToExpression: <T = unknown>({ identifiers, isValueAccess, shorthand, unescape, value, }: {
        identifiers?: string[];
        isValueAccess?: boolean;
        shorthand?: boolean;
        unescape?: boolean;
        value: T;
    }) => ts.Expression | undefined;
};

declare const defaultPaginationKeywords: readonly ["after", "before", "cursor", "offset", "page", "start"];

/**
 * Default plugins used to generate artifacts if plugins aren't specified.
 */
declare const defaultPlugins: readonly ["@hey-api/typescript", "@hey-api/sdk"];

declare const clientDefaultConfig: {
    readonly baseUrl: true;
    readonly bundle: true;
    readonly exportFromIndex: false;
};
declare const clientDefaultMeta: {
    readonly dependencies: readonly ["@hey-api/typescript"];
    readonly output: "client";
    readonly tags: readonly ["client"];
};

declare const clientPluginHandler: ({ plugin, }: Parameters<PluginHandler>[0]) => void;

declare const definePluginConfig: <T extends Plugin.Types>(defaultConfig: Plugin.Config<T>) => (userConfig?: Omit<Plugin.UserConfig<T["config"]>, "name">) => Omit<Plugin.Config<T>, "name"> & {
    /**
     * Cast name to `any` so it doesn't throw type error in `plugins` array.
     * We could allow any `string` as plugin `name` in the object syntax, but
     * that TypeScript trick would cause all string methods to appear as
     * suggested auto completions, which is undesirable.
     */
    name: any;
};

declare const utils: {
    stringCase: ({ case: _case, stripLeadingSeparators, value, }: {
        readonly case: StringCase | undefined;
        stripLeadingSeparators?: boolean;
        value: string;
    }) => string;
};

type Configs = UserConfig | (() => UserConfig) | (() => Promise<UserConfig>);
/**
 * Generate a client from the provided configuration.
 *
 * @param userConfig User provided {@link UserConfig} configuration.
 */
declare const createClient: (userConfig?: Configs) => Promise<ReadonlyArray<Client | IR.Context>>;
/**
 * Type helper for openapi-ts.config.ts, returns {@link UserConfig} object
 */
declare const defineConfig: (config: Configs) => Promise<UserConfig>;

export { IR, Plugin, UserConfig, clientDefaultConfig, clientDefaultMeta, clientPluginHandler, compiler, createClient, defaultPaginationKeywords, defaultPlugins, defineConfig, definePluginConfig, utils };
